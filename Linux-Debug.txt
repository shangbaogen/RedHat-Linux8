编译内核的步骤:
---------------------------------------------------------------------
使用系统默认的x86_64配置文件配置内核,把生成的config文件放到0指定的目录
make 0=/tmp/linux-4.18.20-obj/ x86_64_defconfig

打开内核调试信息,同时关闭内核KASLR(否则无法打内核断点)
[*] Compile the kernel with debug info
[ ] Randomize the address of the kernel image (KASLR)

编译内核,并把输出文件放到0指定的目录
make 0=/tmp/linux-4.18.20-obj/ 


编译busybox的步骤:
-----------------------------------------------------
下载最新的稳定版busybox:
https://busybox.net/downloads/busybox-1.30.1.tar.bz2

解压文件busybox-1.30.1.tar.bz2
#tar xvf busybox-1.30.1.tar.bz2

配置文件:
#cd busybox-1.30.1
#make menuconfig
     Settings  --->
         [*] Build BusyBox as a static binary (no shared libs) //静态方式编译

编译busybox:
#make 

安装busybox:
#make install
执行完该命令后生成如下目录:
#/home/barry-shang/linux-4.18.20/busybox-1.30.1/_install

创建根文件系统:
-----------------------------------------------------------
#mkdir initramfs
#cp -r /home/barry-shang/linux-4.18.20/busybox-1.30.1/_install initramfs
#cd initramfs
#mkdir -pv {bin,sbin,etc,proc,sys,usr/{bin,sbin},dev}

init程序首先会访问etc/inittab文件，因此，我们需要编写inittab，指定开机需要启动的所有程序
#cd etc
#vim inittab
inittab文件的内容如下所示：
::sysinit:/etc/init.d/rcS   
::askfirst:-/bin/sh    
::restart:/sbin/init
::ctrlaltdel:/sbin/reboot
::shutdown:/bin/umount -a -r
::shutdown:/sbin/swapoff -a

赋予可执行权限
#chmod +x inittab

编写系统初始化命令
从inittab文件中可以看出，首先执行的是/etc/init.d/rcS脚本，因此，我们生成初始化脚本

#mkdir init.d
#cd init.d
#vim rcS
rcS文件的内容如下所示：
--------------------- 
#!/bin/sh

mount proc
mount -o remount,rw /
mount -a  
--------------------- 
赋予可执行权限
#chmod +x rcS
在rcS脚本中，mount -a 是自动挂载 /etc/fstab 里面的东西，可以理解为挂在文件系统，因此我们还需要编写 fstab文件来设置我们的文件系统。
#cd etc/
#vim fstab

fstab文件内容如下：
# /etc/fstab
proc            /proc        proc    defaults          0       0
sysfs           /sys         sysfs   defaults          0       0
devtmpfs        /dev         devtmpfs  defaults          0       0

至此，我们已经完成了RAM Disk中相关文件的配置，可以压缩生成文件镜像了。
---------------------------
$ find . -print0 | cpio --null -ov --format=newc | gzip -9 > ../initramfs.cpio.gz

使用qemu启动kernel和rootfs:
qemu-system-x86_64 -kernel linux-4.18.20/arch/x86/boot/bzImage -initrd ./initramfs.cpio.gz -append "console=ttyS0" -nographic

配置qemu启动命令:
qemu-system-x86_64 -m 1024M -smp 2 -kernel ./linux-4.18.20/arch/x86/boot/bzImage -initrd ./linux-4.18.20/rootfs/initramfs.cpio.gz -append "console=ttyS0 apic=debug" -nographic -S -s
-m  为此guest虚拟机预留的内存大小，如果不指定，默认大小是128M
-smp  表示guest虚拟机的cpu的个数

上面两个不是必须的参数选项。
-kernel 后面跟的是要调试的内核bzImage
-initrd  后面跟的是文件系统
-append 后面跟的是虚拟机的cmdline
-nographic  表示启动的是非图形界面的
-S 表示guest虚拟机一启动就会暂停
-s 表示监听tcp:1234端口等待GDB的连接
--------------------- 

printk_ratelimit()这个函数，其作用就如其名，限制printk的打印数量.
使用方法如下:

if(printk_ratelimit())
    printk("****");

该函数的速率控制根据两个文件来确定，分别是:
1. /proc/sys/kernel/printk_ratelimit 限制的时间间隔，默认值是5
2. /proc/sys/kernel/printk_ratelimit_burst 时间间隔内的最大打印条数，默认值是10
所以默认的打印速率是每5秒最多打印10条

Linux ps命令详解:
barry-shang@pek-bshang-d1:~/linux-4.18.20/vm$ ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.0 185396  5556 ?        Ss   Sep30   1:04 /lib/systemd/systemd --system --deserialize 27
root         2  0.0  0.0      0     0 ?        S    Sep30   0:00 [kthreadd]
root         3  0.0  0.0      0     0 ?        S    Sep30   0:16 [ksoftirqd/0]
root         5  0.0  0.0      0     0 ?        S<   Sep30   0:00 [kworker/0:0H]
root         7  0.1  0.0      0     0 ?        S    Sep30 146:23 [rcu_sched]
root         8  0.0  0.0      0     0 ?        S    Sep30   0:00 [rcu_bh]
root         9  0.0  0.0      0     0 ?        S    Sep30   0:02 [migration/0]
root        10  0.0  0.0      0     0 ?        S    Sep30   0:19 [watchdog/0]
barry-s+ 25186  0.2  2.0 1430972 169696 ?      SLl  Nov19 132:02 /opt/google/chrome/chrome
barry-s+ 28386  0.0  0.0   4352   648 pts/21   T    14:36   0:00 ./HelloWorld-getchar

USER   用户名
PID    进程ID（Process ID）
%CPU   进程的cpu占用率
%MEM   进程的内存占用率
VSZ    进程所使用的虚存的大小（Virtual Size）
RSS    进程使用的驻留集大小或者是实际内存的大小，Kbytes字节。
TTY    与进程关联的终端（tty）
STAT   进程的状态：进程状态使用字符表示的（STAT的状态码）
R 运行     Runnable (on run queue)正在运行或在运行队列中等待。
S 睡眠     Sleeping 休眠中, 受阻, 在等待某个条件的形成或接受到信号。
I 空闲     Idle
Z 僵死     Zombie（a defunct process)进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放。
D 不可中断 Uninterruptible sleep (ususally IO)收到信号不唤醒和不可运行, 进程必须等待直到有中断发生。
T 终止     Terminate 进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行。
P 等待交换页
W 无驻留页 has no resident pages 没有足够的记忆体分页可分配。
X 死掉的进程
< 高优先级进程  
N 低优先级进程
L 内存锁页Lock有记忆体分页分配并缩在记忆体内
s 进程的领导者（在它之下有子进程）；
l 多进程的（使用 CLONE_THREAD, 类似 NPTL pthreads）
+ 位于后台的进程组 
START   进程启动时间和日期
TIME    进程使用的总cpu时间
COMMAND 正在执行的命令行命令

Linux alias命令：
命令结构：
alias name='string'
在命令"alias"之后，输入"name"，紧接着(没有空格)是一个等号，等号之后是一串用引号引起的字符串，字符串的内容要赋值给name
[pek-lpd-ccm1:~]$alias vlmstart
alias vlmstart='ssh -Y pek-hig2.wrs.com /folk/vlm/bin/vlmstart'
[pek-lpd-ccm1:~]$type vlmstart
vlmstart is aliased to `ssh -Y pek-hig2.wrs.com /folk/vlm/bin/vlmstart'
[pek-lpd-ccm1:~]$

Linux backport patches steps:
1.先使用git am命令打patch,如果失败使用patch -p1 < ~/test.patch打patch.
2.如果打不上patch,则手动修改.
3.修改完成后,使用git add ~/modify.file
4.使用git am --resolved再次应用,就能把原始patch的log打上.

编译gdb-8.2
#wget http://ftp.gnu.org/gnu/gdb/gdb-8.2.tar.gz
#tar xvf gdb-8.2.tar.gz
#vim gdb-8.2/gdb/remote.c
/*修改gdb-8.2源码，解决remote 'g' too long.*/
/* Further sanity checks, with knowledge of the architecture.  */
//if (buf_len > 2 * rsa->sizeof_g_packet)
// error (_("Remote 'g' packet reply is too long (expected %ld bytes, got %d "
//     "bytes): %s"), rsa->sizeof_g_packet, buf_len / 2, rs->buf);
if (buf_len > 2 * rsa->sizeof_g_packet) {
  rsa->sizeof_g_packet = buf_len;
  for (i = 0; i < gdbarch_num_regs (gdbarch); i++)
  {
      if (rsa->regs[i].pnum == -1)
          continue;
      if (rsa->regs[i].offset >= rsa->sizeof_g_packet)
          rsa->regs[i].in_g_packet = 0;
      else
          rsa->regs[i].in_g_packet = 1;
  }
}
#make
#make install

下载编译最新的qemu-3.1:
#wget https://download.qemu.org/qemu-3.1.0.tar.xz
#tar xvJf qemu-3.1.0.tar.xz
#cd qemu-3.1.0
#./configure --enable-debug  --target-list=x86_64-softmmu 
#make
#make install

/*新的qemu启动命令，指定根文件系*/
qemu-system-x86_64 -m 1024M -smp 2 -kernel /home/barry-shang/linux-4.18.20/git-hub/RedHat-Linux8/linux-4.18.20/arch/x86/boot/bzImage -initrd /home/barry-shang/linux-4.18.20/rootfs/initramfs.cpio.gz -append "console=ttyS0 apic=debug rdinit=/init root=/dev/sda" -nographic -drive if=ide,index=1,format=raw,file=/home/barry-shang/linux-4.18.20/rootfs/hda.img


/*挂在真实的文件系统*/
--------------------------------------------------
modprobe ata_piix

for x in $(cat /proc/cmdline); do
	case $x in
	root=*)
		ROOT=${x#root=}
		;;
	esac
done

echo ${ROOT}
mount ${ROOT} /root

echo "Change to real rootfs!"
exec switch_root -c /dev/console /root /sbin/init
--------------------------------------------------
